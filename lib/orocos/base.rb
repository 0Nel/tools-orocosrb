require 'orogen'
require 'typelib'
require 'utilrb/module/attr_predicate'
require 'orogen'

# The Orocos main class
module Orocos
    class InternalError < Exception; end
    class AmbiguousName < RuntimeError; end
    class PropertyChangeRejected < RuntimeError; end

    def self.register_pkgconfig_path(path)
    	base_path = caller(1).first.gsub(/:\d+:.*/, '')
	ENV['PKG_CONFIG_PATH'] = "#{File.expand_path(path, File.dirname(base_path))}:#{ENV['PKG_CONFIG_PATH']}"
    end

    # Exception raised when the user tries an operation that requires the
    # component to be generated by oroGen, while the component is not
    class NotOrogenComponent < Exception; end
    
    # Base class for all exceptions related to communication with remote
    # processes
    class ComError < RuntimeError; end

    class << self
        # The main configuration manager object
        attr_reader :conf

        # The registry that is the union of all loaded typekits
        #
        # @return [Typelib::Registry]
        def registry
            default_loader.registry
        end

        # If true, the orocos logfile that is being generated by this Ruby
        # process is kept. By default, it gets removed when the ruby process
        # terminates
        attr_predicate :keep_orocos_logfile?

        # The name of the orocos logfile for this Ruby process
        attr_reader :orocos_logfile

        # [RubyTasks::TaskContext] the ruby task context that is used to provide a RTT
        # interface to this Ruby process. Among other things, it manages the
        # data readers and writers
        attr_reader :ruby_task

        # The main oroGen loader object
    end
    @use_mq_warning = true
    @keep_orocos_logfile = false
    
    # The loader object that should be used to load typekits and projects
    #
    # @see default_pkgconfig_loader
    def self.default_loader
        default_pkgconfig_loader
    end

    # The loader object that should be used to load installed oroGen typekits
    # and projects
    #
    # @see default_loader
    def self.default_pkgconfig_loader
        @default_pkgconfig_loader ||= OroGen::Loaders::PkgConfig.new(orocos_target)
    end

    def self.orocos_target
        if ENV['OROCOS_TARGET']
            ENV['OROCOS_TARGET']
        else
            'gnulinux'
        end
    end

    class << self
        # The set of extension names seen so far
        #
        # Whenever a new extension is encountered, Orocos.task_model_from_name
        # tries to require 'extension_name/runtime', which might no exist. Once
        # it has done that, it registers the extension name in this set to avoid
        # trying loading it again
        attr_reader :known_orogen_extensions
    end
    @known_orogen_extensions = Set.new

    # Loads a directory containing configuration files
    #
    # See the documentation of ConfigurationManager#load_dir for more
    # information
    def self.load_config_dir(dir)
        conf.load_dir(dir)
    end

    # Returns true if Orocos.load has been called
    def self.loaded?
        !!@default_loader
    end

    def self.load(name = nil)
        if ENV['ORO_LOGFILE'] && orocos_logfile && (ENV['ORO_LOGFILE'] != orocos_logfile)
            raise "trying to change the path to ORO_LOGFILE from #{orocos_logfile} to #{ENV['ORO_LOGFILE']}. This is not supported"
        end
        ENV['ORO_LOGFILE'] ||= File.expand_path("orocos.#{name || 'orocosrb'}-#{::Process.pid}.txt")
        @orocos_logfile = ENV['ORO_LOGFILE']

        if @available_projects && !@available_projects.empty?
            return
        end

        if @registry
            raise ArgumentError, "you must call Orocos.clear before calling Orocos.load again"
        end

        @conf = ConfigurationManager.new
        @master_project = OroGen::Spec::Project.new
        @registry = Typelib::Registry.new
        default_loader.on_project_load do |project|
            if !project.self_tasks.empty?
                master_project.using_task_library project
            end
        end
        default_loader.on_typekit_load do |typekit|
            master_project.using_typekit typekit
            if Orocos.export_types?
                Orocos.info "exporting registry to Ruby"
                Orocos.export_registry_to_ruby
            end
        end
        @loaded_typekit_plugins.clear
        load_standard_typekits

        if Orocos::ROS.enabled?
            if !Orocos::ROS.loaded?
                # Loads all ROS projects that can be found in
                # Orocos::ROS#spec_search_directories
                Orocos::ROS.load
            end
        end

        nil
    end

    def self.clear
        @default_loader = nil
        @ruby_task.dispose if @ruby_task
        if export_types? && registry
            registry.clear_exports(type_export_namespace)
        end
        @registry = nil

        name_service.clear
        if defined? Orocos::Async
            Orocos::Async.clear
        end
    end

    def self.reset
        clear
        load
    end

    class << self
        attr_predicate :disable_sigchld_handler, true
    end

    # Returns true if Orocos.initialize has been called and completed
    # successfully
    def self.initialized?
        CORBA.initialized?
    end

    # Initialize the Orocos communication layer and load all the oroGen models
    # that are available.
    #
    # This method will verify that the pkg-config environment is sane, as it is
    # demanded by the oroGen deployments. If it is not the case, it will raise
    # a RuntimeError exception whose message will describe the particular
    # problem. See the "Error messages" package in the user's guide for more
    # information on how to fix those.
    def self.initialize(name = "orocosrb_#{::Process.pid}")
        if !registry
            self.load(name)
        end

        # Install the SIGCHLD handler if it has not been disabled
        if !disable_sigchld_handler?
            trap('SIGCHLD') do
                begin
                    while dead = ::Process.wait(-1, ::Process::WNOHANG)
                        if mod = Orocos::Process.from_pid(dead)
                            mod.dead!($?)
                        end
                    end
                rescue Errno::ECHILD
                end
            end
        end

        if !Orocos::CORBA.initialized?
            Orocos::CORBA.initialize
        end
        @initialized = true

        if Orocos::ROS.enabled?
            # ROS does not support being teared down and reinitialized.
            if !Orocos::ROS.initialized?
                Orocos::ROS.initialize(name)
            end
        end

        # add default name services
        self.name_service << Orocos::CORBA.name_service
        if defined?(Orocos::ROS) && Orocos::ROS.enabled?
            self.name_service << Orocos::ROS.name_service
        end
        if defined?(Orocos::Async)
            Orocos.name_service.name_services.each do |ns|
                Orocos::Async.name_service.add(ns)
            end
        end
        @ruby_task = RubyTasks::TaskContext.new(name)

        Orocos.load_typekit 'std'
    end
end

at_exit do
    if !Orocos.keep_orocos_logfile? && Orocos.orocos_logfile
        FileUtils.rm_f Orocos.orocos_logfile
    end
end

